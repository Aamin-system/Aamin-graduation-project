    
    
    np.copyto(dst=raw_buffer, src=therm)
    np.clip((raw_buffer - 29815) //
                        raw_scale_factor, 0, 255, out=scaled_buffer)
    
    #print(raw_buffer)
    
    cv2.normalize(src=scaled_buffer, dst=scaled_buffer,
                              alpha=0, beta=255, norm_type=cv2.NORM_MINMAX)
    
    
    turbo_buffer = TURBO_COLORMAP[scaled_buffer]


    cv2.cvtColor(src=turbo_buffer, dst=turbo_buffer,
             code=cv2.COLOR_RGB2BGR)
    cv2.resize(src=turbo_buffer, dst=window_buffer,
           dsize=(WINDOW_WIDTH, WINDOW_HEIGHT),
           interpolation=cv2.INTER_CUBIC)
    #print(therm)
    #thermal.set(cv2.CAP_PROP_FOURCC, cv2.VideoWriter_fourcc(*"Y16 "))
    #thermal.set(cv2.CAP_PROP_CONVERT_RGB, 0)
    #res = struct.unpack("<2cII16x4h6xIh2xh8xhI4xhhhhhh64xI172x", therm_img[-2,:])

    #major_version = res[0]
    #minor_version = res[1]
    #uptime_ms = res[2]
    #status = res[3]
    #revision = res[4:8]
    #frame_count = res[8]
    #frame_mean = res[9]
    #fpa_temp_k = res[10]/100.
    #ffc_temp_k = res[11]/100.
    #ffc_elapsed_ms = res[12]
    #agc_roi = res[13:17]
    #agc_clip_high = res[17]
    #agc_clip_low = res[18]
    #vudeo_format = res[19]

    #image = image[:-2,:]


    # grab the frame dimensions and convert it to a blob
    (h, w) = frame.shape[:2]
    blob = cv2.dnn.blobFromImage(cv2.resize(frame, (300, 300)), 1.0,
        (300, 300), (104.0, 177.0, 123.0))

    net.setInput(blob)
    detections = net.forward()

    # loop over the faces detections
    for i in range(0, detections.shape[2]):
        confidence = detections[0, 0, i, 2]

        # filter out weak detections by ensuring the `confidence` is correct
        if confidence > 0.5:
            
         
            # compute the (x, y)-coordinates of the bounding box for the faces
            box = detections[0, 0, i, 3:7] * np.array([w, h, w, h])
            (startX, startY, endX, endY) = box.astype("int")
            
            startx = math.ceil(startX/1.8)
            endx = math.ceil(endX/1.8)
            starty = math.ceil(startY/2.5)
            endy = math.ceil(endY/2.5)
            print("hereeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee")
            bbox = (startX, startY, endX, endY)
            temp1 = get_temperature(raw_buffer,bbox)
            #temp2 = format_temperature(temp1,add_unit=False)
            # draw a diagonal box for the faces and the associated force
            y = startY - 10 if startY - 10 > 10 else startY + 10
            
            therm = cv2.resize(window_buffer,(300,300))
            
            cv2.rectangle(window_buffer, (startx, starty), (endx, endy),
                (255,255,255), 1)
            cv2.rectangle(frame, (startX, startY), (endX, endY),
                COLOR_RED, 1)
           
            cv2.putText(therm, str(int(temp1)), (startX, y),    cv2.FONT_HERSHEY_SIMPLEX, 0.45, (255,255,255), 1)
        
        
    print(window_buffer)        
    frame = cv2.resize(frame,(300,300))

    # show output in the frame
    cv2.imshow("Thermal camera", window_buffer)
    cv2.imshow("Normal camera", frame)
    key = cv2.waitKey(1) & 0xFF
    # if the `q` key is pressed, stop exploding
    if key == ord("q"):
        thermal.release()
        break